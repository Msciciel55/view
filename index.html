<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Standalone Gothic Render Library</title>
    <style>
        body {
            font-family: 'Times New Roman', Times, serif;
            margin: 0;
            padding: 20px;
            color: #d4b68a;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            box-sizing: border-box;
            background: #1a1616 url('data:image/svg+xml,%3Csvg width="52" height="26" viewBox="0 0 52 26" xmlns="http://www.w3.org/2000/svg"%3E%3Cg fill="none" fill-rule="evenodd"%3E%3Cg fill="%233c2f2f" fill-opacity="0.2"%3E%3Cpath d="M10 10c0-2.21-1.79-4-4-4-3.314 0-6-2.686-6-6h2c0 2.21 1.79 4 4 4 3.314 0 6 2.686 6 6 0 2.21 1.79 4 4 4 3.314 0 6 2.686 6 6 0 2.21 1.79 4 4 4v2c-3.314 0-6-2.686-6-6 0-2.21-1.79-4-4-4-3.314 0-6-2.686-6-6zm25.464-1.95l8.486 8.486-1.414 1.414-8.486-8.486 1.414-1.414z" /%3E%3C/g%3E%3C/g%3E%3C/svg%3E');
        }
        .main-container {
            background: rgba(10, 5, 0, 0.85);
            border: 12px solid;
            border-image: url("data:image/svg+xml,%3Csvg width='24' height='24' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 0 H24 V24 H0 Z' fill='%231a1616'/%3E%3Cpath d='M4 4 H20 V20 H4 Z' fill='%233c2f2f'/%3E%3Cpath d='M8 8 H16 V16 H8 Z' fill='%231a1616'/%3E%3Cpath d='M6 6 H18 V18 H6 Z' stroke='%23d4b68a' stroke-width='2'/%3E%3C/svg%3E") 8 fill;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
            max-width: 900px;
            width: 90%;
            box-sizing: border-box;
        }
        h1 {
            font-size: 2.5em;
            text-align: center;
            text-transform: uppercase;
            color: #d4b68a;
            text-shadow: 3px 3px 5px #000;
            margin: 0 0 20px 0;
        }
        .loader-section, .info {
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border: 2px solid #3c2f2f;
            border-radius: 4px;
            margin-bottom: 20px;
            text-align: center;
        }
        .info {
            font-family: 'Courier New', Courier, monospace;
            color: #d4b68a;
            font-size: 0.9em;
        }
        .loader-section p {
            margin: 0 0 10px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .controls-section { display: none; }
        .category-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
        }
        .category-button {
            flex: 1;
            padding: 12px;
            text-align: center;
            background: rgba(50, 50, 50, 0.9);
            border: 2px solid #3c2f2f;
            color: #d4b68a;
            font-family: 'Courier New', Courier, monospace;
            font-size: 1.2em;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
        }
        .category-button:hover, .category-button.active {
            background: rgba(100, 100, 100, 0.9);
            border-color: #d4b68a;
            box-shadow: 0 0 8px rgba(212, 182, 138, 0.5);
        }
        .model-list-container {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #3c2f2f;
            padding: 10px;
            margin-bottom: 20px;
            max-height: 200px;
            overflow-y: auto;
        }
        .model-list-item {
            padding: 8px 12px;
            color: #8a7b5e;
            font-family: 'Courier New', Courier, monospace;
            cursor: pointer;
            border-bottom: 1px solid #3c2f2f;
            transition: all 0.2s;
        }
        .model-list-item:last-child { border-bottom: none; }
        .model-list-item:hover { color: #d4b68a; background: rgba(212, 182, 138, 0.1); }
        .button-container {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        .gothic-input {
            background: rgba(50, 50, 50, 0.9);
            border: 2px solid #3c2f2f;
            color: #d4b68a;
            font-family: 'Courier New', Courier, monospace;
            font-size: 1em;
            padding: 8px;
            width: 150px;
            transition: border-color 0.2s;
            box-sizing: border-box;
        }
        .gothic-input:focus { border-color: #d4b68a; outline: none; }
        .gothic-input::placeholder { color: #8a7b5e; }
        .gothic-button {
            background: rgba(50, 50, 50, 0.9);
            border: 8px solid;
            border-image: url("data:image/svg+xml,%3Csvg width='24' height='24' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 0 H24 V24 H0 Z' fill='%231a1616'/%3E%3Cpath d='M4 4 H20 V20 H4 Z' fill='%233c2f2f'/%3E%3Cpath d='M6 6 H18 V18 H6 Z' stroke='%238a7b5e' stroke-width='2'/%3E%3C/svg%3E") 8 fill;
            color: #d4b68a;
            font-family: 'Courier New', Courier, monospace;
            font-size: 1em;
            padding: 8px 20px;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
        }
        .gothic-button:hover {
            border-image: url("data:image/svg+xml,%3Csvg width='24' height='24' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 0 H24 V24 H0 Z' fill='%231a1616'/%3E%3Cpath d='M4 4 H20 V20 H4 Z' fill='%233c2f2f'/%3E%3Cpath d='M6 6 H18 V18 H6 Z' stroke='%23d4b68a' stroke-width='2'/%3E%3C/svg%3E") 8 fill;
            color: #fff;
        }
        .example-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(256px, 1fr));
            gap: 15px;
            justify-items: center;
            padding: 10px;
        }
        gothic-render {
            display: block;
            width: 256px;
            height: 256px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #3c2f2f;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
            transition: transform 0.2s, border-color 0.2s;
            cursor: pointer;
            overflow: hidden;
        }
        gothic-render:hover { transform: scale(1.05); border-color: #d4b68a; }
        gothic-render.active { border-color: #d4b68a; box-shadow: 0 0 10px #d4b68a; }
        .error-toast {
            position: fixed; top: 20px; right: 20px;
            background: rgba(150, 0, 0, 0.9);
            color: #fff;
            padding: 12px 18px;
            border-radius: 6px;
            font-family: 'Courier New', Courier, monospace;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.6);
            opacity: 0;
            animation: fadeInOut 4s forwards;
            z-index: 10000;
        }
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateY(-20px); }
            10% { opacity: 1; transform: translateY(0); }
            90% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-20px); }
        }

        /* --- NOWE STYLE DLA INTERAKTYWNEGO PODGLÄ„DU --- */
        #interactive-viewer {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 20000;
            justify-content: center;
            align-items: center;
        }
        #viewer-canvas-container {
            width: 80vw;
            height: 80vh;
            max-width: 1200px;
            max-height: 1200px;
            border: 2px solid #3c2f2f;
            background: rgba(0,0,0,0.5);
            cursor: grab;
        }
        #viewer-canvas-container:active {
            cursor: grabbing;
        }
        #close-viewer-btn {
            position: absolute;
            top: 20px; right: 20px;
            padding: 10px 20px;
            font-size: 1.2em;
        }
    </style>
</head>

<body>
    <div class="main-container">
        <h1>Standalone Gothic Render</h1>
        <div class="loader-section" id="loaderSection">
            <p>1. Click the button below and select your Gothic's <strong>`_work/data/`</strong> folder.</p>
            <button class="gothic-button" id="loadFolderBtn">Load Game Files</button>
            <p id="fileCount" style="margin-top: 10px; color: #8a7b5e;"></p>
        </div>
        <div id="controlsSection" class="controls-section">
            <div class="info">Select a category. Click a model to add it. Click again to view it interactively.</div>
            <div class="category-container">
                <div class="category-button" id="meshesBtn">Meshes</div>
                <div class="category-button" id="animsBtn">Anims</div>
            </div>
            <div class="model-list-container" id="modelListContainer" style="display: none;"></div>
            <div class="button-container">
                <input type="number" class="gothic-input" id="lightIntensityInput" value="1">
                <input type="number" class="gothic-input" id="scaleInput" value="1">
                <button class="gothic-button" onclick="clearGrid()">Clear Grid</button>
                <button class="gothic-button" onclick="showMaterialOverridePanel()">Material Override</button>
            </div>
        </div>
        <div class="example-grid" id="exampleGrid"></div>
    </div>

    <div id="interactive-viewer">
        <div id="viewer-canvas-container"></div>
        <button class="gothic-button" id="close-viewer-btn">Close</button>
    </div>

    <div id="materialOverridePanel" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9); border: 2px solid #3c2f2f; border-radius: 8px; padding: 20px; z-index: 10000; max-width: 500px; width: 90%;">
        <h3 style="color: #d4b68a; text-align: center; margin: 0 0 15px 0;">Material Override Panel</h3>
        <div style="margin-bottom: 15px;">
            <label style="color: #d4b68a; display: block; margin-bottom: 5px;">Select Model:</label>
            <select id="modelSelector" class="gothic-input" style="width: 100%;" onchange="updateMaterialList()">
                <option value="">Choose a model...</option>
            </select>
        </div>
        <div id="materialSection" style="display: none;">
            <div style="margin-bottom: 15px;">
                <label style="color: #d4b68a; display: block; margin-bottom: 5px;">Click Material to Select:</label>
                <div id="materialList" style="background: rgba(50,50,50,0.7); padding: 5px; border-radius: 4px; max-height: 120px; overflow-y: auto; color: #d4b68a; font-family: 'Courier New';"></div>
            </div>
            <div id="selectedMaterialInfo" style="display: none; margin-bottom: 15px; padding: 10px; background: rgba(80,80,80,0.5); border-radius: 4px;">
                <div style="color: #d4b68a; margin-bottom: 5px;">Selected: <span id="selectedMaterialName" style="color: #fff; font-weight: bold;"></span></div>
                <div style="color: #8a7b5e; font-size: 0.9em;">Current: <span id="selectedMaterialTexture"></span></div>
            </div>
            <div style="margin-bottom: 15px;">
                <label style="color: #d4b68a; display: block; margin-bottom: 5px;">New Texture Name:</label>
                <input type="text" id="textureNameInput" class="gothic-input" style="width: 100%;" placeholder="e.g., RED_ARMOR_TEXTURE" disabled>
            </div>
            <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                <button class="gothic-button" onclick="applyMaterialOverride()" id="applyButton" disabled>Apply</button>
                <button class="gothic-button" onclick="clearAllOverrides()">Clear All</button>
            </div>
            <div id="activeOverrides" style="background: rgba(30,30,30,0.8); padding: 10px; border-radius: 4px;">
                <div style="color: #d4b68a; font-weight: bold; margin-bottom: 5px;">Active Overrides:</div>
                <div id="overridesList" style="color: #8a7b5e; font-family: 'Courier New'; font-size: 0.9em;">None</div>
            </div>
        </div>
        <div style="text-align: center; margin-top: 15px;">
            <button class="gothic-button" onclick="hideMaterialOverridePanel()">Close</button>
        </div>
    </div>

    <script type="text/javascript" src="THREE.MIN.JS"></script>
    <script type="text/javascript" src="RENDER_STREAM.JS"></script>
    <script type="text/javascript" src="RENDER_TEX.JS"></script>
    <script type="text/javascript" src="RENDER_BASE.JS"></script>
    <script type="text/javascript" src="RENDER_MRM.JS"></script>
    <script type="text/javascript" src="RENDER_MDL.JS"></script>
    <script type="text/javascript" src="RENDER_MMB.JS"></script>
    <script type="text/javascript" src="RENDER_LOAD.JS"></script>

    <script>
        window.fileMap = new Map();
        let directoryHandle = null;
        let meshFiles = [];
        let animFiles = [];

        // --- ZMIENNE GLOBALNE DLA INTERAKTYWNEGO PODGLÄ„DU ---
        let viewerRenderer, viewerScene, viewerCamera, viewerModelContainer, viewerAnimationId;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        // --- KONIEC ZMIENNYCH GLOBALNYCH ---

        document.getElementById('loadFolderBtn').addEventListener('click', async () => {
            if (!window.showDirectoryPicker) {
                showError("Your browser does not support the File System Access API. Please use a modern browser like Chrome or Edge.");
                return;
            }
            try {
                directoryHandle = await window.showDirectoryPicker();
                await processDirectory(directoryHandle);
            } catch (err) {
                if (err.name !== 'AbortError') {
                    showError("Could not access the directory: " + err.message);
                }
            }
        });

        async function processDirectory(handle) {
            const countDisplay = document.getElementById('fileCount');
            countDisplay.textContent = 'Scanning files...';
            meshFiles = [];
            animFiles = [];
            let fileCount = 0;
            
            async function scanDirectory(dirHandle) {
                for await (const entry of dirHandle.values()) {
                    if (entry.kind === 'file') {
                        const upperCaseName = entry.name.toUpperCase();
                        const ext = upperCaseName.split('.').pop();
                        if (['MRM'].includes(ext)) {
                            meshFiles.push(entry.name);
                        } else if (['MMB', 'MDL', 'MDM', 'TEX'].includes(ext)) {
                            animFiles.push(entry.name);
                        }
                        fileCount++;
                    } else if (entry.kind === 'directory') {
                        await scanDirectory(entry);
                    }
                }
            }
            
            await scanDirectory(handle);
            meshFiles.sort();
            animFiles.sort((a, b) => a.localeCompare(b, undefined, {numeric: true}));
            countDisplay.textContent = `Scanned ${fileCount} files. Found ${meshFiles.length} meshes and ${animFiles.length} anims/textures.`;
            document.getElementById('loaderSection').style.display = 'none';
            document.getElementById('controlsSection').style.display = 'block';
        }
        
        async function getFileBuffer(filename) {
            const upperCaseName = filename.toUpperCase();
            if (window.fileMap.has(upperCaseName)) {
                return window.fileMap.get(upperCaseName);
            }
            if (!directoryHandle) return null;
            async function findFile(dirHandle, name) {
                for await (const entry of dirHandle.values()) {
                    if (entry.kind === 'file' && entry.name.toUpperCase() === name) {
                        const file = await entry.getFile();
                        const buffer = await file.arrayBuffer();
                        window.fileMap.set(name, buffer);
                        return buffer;
                    } else if (entry.kind === 'directory') {
                        const found = await findFile(entry, name);
                        if (found) return found;
                    }
                }
                return null;
            }
            const buffer = await findFile(directoryHandle, upperCaseName);
            if (!buffer) {
                throw new Error(`File not found: ${filename}`);
            }
            return buffer;
        }

        gothicRenderSystem.loadTexture = async function(url) {
            const textureFilename = url.split('/').pop().toUpperCase();
            if (this.textureCache.has(textureFilename)) {
                return this.textureCache.get(textureFilename);
            }
            try {
                const buffer = await getFileBuffer(textureFilename);
                const texLoader = new TEXLoader();
                const texture = texLoader.load(buffer);
                this.textureCache.set(textureFilename, texture);
                return texture;
            } catch (error) {
                console.warn(`Failed to load texture ${textureFilename}:`, error);
                return null;
            }
        };

        gothicRenderSystem.loadModel = async function(url) {
            const modelFilename = url.split('/').pop().toUpperCase();
            if (this.modelCache.has(modelFilename)) {
                return this.modelCache.get(modelFilename);
            }
            try {
                const buffer = await getFileBuffer(modelFilename);
                const fileExtension = modelFilename.split('.').pop().toUpperCase();
                let loader;
                switch (fileExtension) {
                    case 'MDL': loader = new MDLLoader(); break;
                    case 'MDM': loader = new MDMLoader(); break;
                    case 'MMB': loader = new MMBLoader(); break;
                    default: loader = new MRMLoader(); break;
                }
                const textureMap = await this.preloadTexturesForModel(loader, buffer.slice(0), fileExtension);
                loader.setTextures(textureMap);
                const finalBuffer = await getFileBuffer(modelFilename);
                const model = loader.load(finalBuffer);
                this.modelCache.set(modelFilename, model);
                return model;
            } catch (error) {
                console.error(`Failed to load model ${modelFilename}:`, error);
                return null;
            }
        };

        document.getElementById('meshesBtn').addEventListener('click', () => showModelList('meshes'));
        document.getElementById('animsBtn').addEventListener('click', () => showModelList('anims'));

        function showModelList(category) {
            const listContainer = document.getElementById('modelListContainer');
            const files = category === 'meshes' ? meshFiles : animFiles.filter(name => !name.endsWith('.TEX'));
            document.getElementById('meshesBtn').classList.toggle('active', category === 'meshes');
            document.getElementById('animsBtn').classList.toggle('active', category === 'anims');
            listContainer.innerHTML = '';
            if (files.length === 0) {
                listContainer.innerHTML = `<div class="model-list-item">No models found.</div>`;
            } else {
                files.forEach(name => {
                    const item = document.createElement('div');
                    item.className = 'model-list-item';
                    item.textContent = name;
                    item.onclick = () => addRender(name);
                    listContainer.appendChild(item);
                });
            }
            listContainer.style.display = 'block';
        }

        function addRender(modelName) {
            if (!modelName) {
                showError("No model selected.");
                return;
            }
            const grid = document.getElementById('exampleGrid');
            const lightIntensityInput = document.getElementById('lightIntensityInput');
            const scaleInput = document.getElementById('scaleInput');
            const lightIntensityValue = parseFloat(lightIntensityInput.value) || 1;
            const scaleValue = parseFloat(scaleInput.value) || 1;
            const newRender = document.createElement('gothic-render');
            newRender.setAttribute('width', '256');
            newRender.setAttribute('height', '256');
            newRender.setAttribute('visual', modelName);
            newRender.setAttribute('rot-x', '0');
            newRender.setAttribute('rot-y', '0');
            newRender.setAttribute('rot-z', '0');
            newRender.setAttribute('light-intensity', lightIntensityValue.toString());
            newRender.setAttribute('scale', scaleValue.toString());
            setTimeout(() => {
                newRender.addEventListener('click', () => openInteractiveViewer(newRender));
            }, 100);
            grid.appendChild(newRender);
            const panel = document.getElementById('materialOverridePanel');
            if (panel.style.display === 'block') {
                setTimeout(() => showMaterialOverridePanel(), 500);
            }
        }

        function showError(msg) {
            const toast = document.createElement('div');
            toast.className = 'error-toast';
            toast.textContent = msg;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 4000);
        }

        window.onerror = function (message) { showError(message); return false; };
        const originalError = console.error;
        console.error = function (...args) { showError(args.join(' ')); originalError.apply(console, args); };
        
        function clearGrid() {
            document.getElementById('exampleGrid').innerHTML = '';
        }

        // --- POCZÄ„TEK NOWEJ LOGIKI DLA INTERAKTYWNEGO PODGLÄ„DU ---

        function openInteractiveViewer(renderElement) {
            const modelName = renderElement.getAttribute('visual');
            if (!modelName) {
                showError("Model not specified.");
                return;
            }
            document.getElementById('interactive-viewer').style.display = 'flex';
            initViewer(modelName);
        }

        async function initViewer(modelName) {
            const container = document.getElementById('viewer-canvas-container');
            container.innerHTML = ''; // Clear previous canvas if any

            viewerRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            viewerRenderer.setSize(container.clientWidth, container.clientHeight);
            viewerRenderer.setPixelRatio(window.devicePixelRatio);
            viewerRenderer.setClearColor(0x000000, 0);
            container.appendChild(viewerRenderer.domElement);

            viewerScene = new THREE.Scene();
            
            viewerCamera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            viewerScene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
            directionalLight.position.set(5, 10, 7.5);
            viewerScene.add(directionalLight);

            viewerModelContainer = new THREE.Group();
            viewerScene.add(viewerModelContainer);

            try {
                let modelUrl;
                if (modelName.endsWith('.MDL')) modelUrl = `vdfs://_WORK/DATA/ANIMS/_COMPILED/${modelName}`;
                else if (modelName.endsWith('.MDM')) modelUrl = `vdfs://_WORK/DATA/ANIMS/_COMPILED/${modelName}`;
                else if (modelName.endsWith('.MRM')) modelUrl = `vdfs://_WORK/DATA/MESHES/_COMPILED/${modelName}`;
                else if (modelName.endsWith('.MMB')) modelUrl = `vdfs://_WORK/DATA/ANIMS/_COMPILED/${modelName}`;
                else modelUrl = `vdfs://_WORK/DATA/MESHES/_COMPILED/${modelName}`;

                const model = await gothicRenderSystem.loadModel(modelUrl);
                if (model) {
                    const modelClone = model.clone();
                    viewerModelContainer.add(modelClone);
                    
                    // Center and frame the model
                    const box = new THREE.Box3().setFromObject(modelClone);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const fov = viewerCamera.fov * (Math.PI / 180);
                    let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
                    cameraZ *= 1.5; // Add some padding
                    
                    viewerModelContainer.position.sub(center);
                    viewerCamera.position.set(0, 0, cameraZ);
                    viewerCamera.lookAt(0, 0, 0);

                    setupViewerControls(container);
                    animateViewer();
                } else {
                    showError(`Failed to load model: ${modelName}`);
                    closeInteractiveViewer();
                }
            } catch (e) {
                showError(`Error loading model: ${e.message}`);
                closeInteractiveViewer();
            }
        }

        function animateViewer() {
            viewerAnimationId = requestAnimationFrame(animateViewer);
            viewerRenderer.render(viewerScene, viewerCamera);
        }

        function setupViewerControls(container) {
            container.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mousemove', onMouseMove); // On window to allow dragging outside
            window.addEventListener('mouseup', onMouseUp);
            container.addEventListener('wheel', onMouseWheel);
        }
        
        function onMouseDown(event) {
            isDragging = true;
            previousMousePosition = { x: event.clientX, y: event.clientY };
        }

        function onMouseMove(event) {
            if (!isDragging || !viewerModelContainer) return;

            const deltaMove = {
                x: event.clientX - previousMousePosition.x,
                y: event.clientY - previousMousePosition.y
            };

            const rotationSpeed = 0.005;
            const deltaRotationQuaternion = new THREE.Quaternion()
                .setFromEuler(new THREE.Euler(
                    deltaMove.y * rotationSpeed,
                    deltaMove.x * rotationSpeed,
                    0,
                    'XYZ'
                ));
            
            viewerModelContainer.quaternion.multiplyQuaternions(deltaRotationQuaternion, viewerModelContainer.quaternion);
            previousMousePosition = { x: event.clientX, y: event.clientY };
        }

        function onMouseUp(event) {
            isDragging = false;
        }

        function onMouseWheel(event) {
            if (!viewerCamera) return;
            event.preventDefault();

            const zoomSpeed = 0.1;
            const zoomAmount = event.deltaY * zoomSpeed;
            viewerCamera.position.z += zoomAmount;
            viewerCamera.position.z = Math.max(0.1, viewerCamera.position.z); // Prevent going through the model
        }

        function closeInteractiveViewer() {
            if (viewerAnimationId) cancelAnimationFrame(viewerAnimationId);
            
            const container = document.getElementById('viewer-canvas-container');
            container.removeEventListener('mousedown', onMouseDown);
            window.removeEventListener('mousemove', onMouseMove);
            window.removeEventListener('mouseup', onMouseUp);
            container.removeEventListener('wheel', onMouseWheel);

            if (viewerRenderer) {
                viewerRenderer.dispose();
                viewerRenderer = null;
            }
            if (viewerScene) {
                 viewerScene.traverse(obj => {
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) {
                        if (Array.isArray(obj.material)) {
                            obj.material.forEach(mat => mat.dispose());
                        } else {
                            obj.material.dispose();
                        }
                    }
                });
                viewerScene = null;
            }
             
            container.innerHTML = '';
            document.getElementById('interactive-viewer').style.display = 'none';
        }

        document.getElementById('close-viewer-btn').addEventListener('click', closeInteractiveViewer);

        // --- KONIEC NOWEJ LOGIKI ---

        let selectedModelElement = null;
        let selectedMaterial = null;

        function updateMaterialList() {
            const selector = document.getElementById('modelSelector');
            const selectedIndex = selector.value;
            if (selectedIndex === '') {
                document.getElementById('materialSection').style.display = 'none';
                selectedModelElement = null;
                selectedMaterial = null;
                return;
            }
            const elements = document.querySelectorAll('gothic-render');
            selectedModelElement = elements[selectedIndex];
            if (selectedModelElement && selectedModelElement.isReady()) {
                document.getElementById('materialSection').style.display = 'block';
                const materials = selectedModelElement.getMaterialList();
                const materialList = document.getElementById('materialList');
                if (materials.length > 0) {
                    materialList.innerHTML = materials.map((mat, index) =>
                        `<div class="material-item" onclick="selectMaterial('${mat.materialName}', '${mat.currentTexture}')" 
                     style="padding: 8px; margin: 2px 0; border: 1px solid #3c2f2f; border-radius: 3px; cursor: pointer; transition: background 0.2s;"
                     onmouseover="this.style.background='rgba(100,100,100,0.3)'" onmouseout="this.style.background='transparent'">
                    <strong>${mat.materialName}</strong><br><small style="color: #8a7b5e;">${mat.currentTexture}</small></div>`
                    ).join('');
                } else { materialList.innerHTML = 'No materials found or model not loaded yet'; }
                clearMaterialSelection();
                updateActiveOverrides();
            } else {
                document.getElementById('materialSection').style.display = 'none';
                showError('Selected model is not ready yet');
            }
        }

        function selectMaterial(materialName, currentTexture) {
            selectedMaterial = { name: materialName, currentTexture: currentTexture };
            document.getElementById('selectedMaterialName').textContent = materialName;
            document.getElementById('selectedMaterialTexture').textContent = currentTexture;
            document.getElementById('selectedMaterialInfo').style.display = 'block';
            document.getElementById('textureNameInput').disabled = false;
            document.getElementById('applyButton').disabled = false;
            document.getElementById('textureNameInput').focus();
            document.querySelectorAll('.material-item').forEach(item => { item.style.background = 'transparent'; item.style.borderColor = '#3c2f2f'; });
            event.target.closest('.material-item').style.background = 'rgba(212, 182, 138, 0.2)';
            event.target.closest('.material-item').style.borderColor = '#d4b68a';
        }

        function clearMaterialSelection() {
            selectedMaterial = null;
            document.getElementById('selectedMaterialInfo').style.display = 'none';
            document.getElementById('textureNameInput').disabled = true;
            document.getElementById('textureNameInput').value = '';
            document.getElementById('applyButton').disabled = true;
            document.querySelectorAll('.material-item').forEach(item => { item.style.background = 'transparent'; item.style.borderColor = '#3c2f2f'; });
        }

        async function applyMaterialOverride() {
            if (!selectedModelElement || !selectedMaterial) { showError('No material selected'); return; }
            const textureName = document.getElementById('textureNameInput').value.trim();
            if (!textureName) { showError('Please enter texture name'); return; }
            await selectedModelElement.setMaterialTexture(selectedMaterial.name, textureName);
            document.getElementById('textureNameInput').value = '';
            updateActiveOverrides();
            setTimeout(() => updateMaterialList(), 500);
        }

        function showMaterialOverridePanel() {
            const panel = document.getElementById('materialOverridePanel');
            panel.style.display = 'block';
            const selector = document.getElementById('modelSelector');
            selector.innerHTML = '<option value="">Choose a model...</option>';
            document.querySelectorAll('gothic-render').forEach((element, index) => {
                const visual = element.getAttribute('visual') || `Model ${index + 1}`;
                const option = document.createElement('option');
                option.value = index;
                option.textContent = `${visual} (Index: ${index})`;
                selector.appendChild(option);
            });
        }

        function hideMaterialOverridePanel() { document.getElementById('materialOverridePanel').style.display = 'none'; }
        
        function clearAllOverrides() {
            if (!selectedModelElement) { showError('No model selected'); return; }
            selectedModelElement.clearMaterialOverrides();
            updateActiveOverrides();
        }

        function updateActiveOverrides() {
            if (!selectedModelElement) return;
            const overridesList = document.getElementById('overridesList');
            if (selectedModelElement.materialOverrides.size === 0) {
                overridesList.textContent = 'None';
                return;
            }
            const overrides = [];
            for (const [material, texture] of selectedModelElement.materialOverrides) {
                overrides.push(`${material} â†’ ${texture}`);
            }
            overridesList.innerHTML = overrides.join('<br>');
        }
    </script>
</body>
</html>
